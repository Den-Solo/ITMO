так как N - количество недостающих крышек не превышает 20, то разумно использовать битовый маски для записи наборов крышек (если крышка с номером есть, то 1 иначе - 0).

заведем массив prices[0..(1 << 20)], где ключ - битова маска, а значение - минимальная стоимость такого набора (по маске).

Для пустого набора это 0. Остальные высталяем на большое число (больше макс. суммы) = inf.

реккурентное соотношение:

prices[mask] = min(
	prices[mask], 
	prices[mask & ~other_mask] + cost[other_mask]
);

other_mask - маска одного из предложенных наборов, ~ - оператор битового отрицания. Операция побитового & позволяемт определить, есть ли у нашей маски и предложенного набора одинаковые выставленные биты - то есть подходящие крышки.

cost[other_mask] - исходная стоимость такого набора из входных даных.

Весь алгоритм: проходимся по всем предложенным для покупки наборам, и если в этом наборе и требуемом есть одинаковые крышки, то получаем маску пересечения нашего набора и покупаемого и рекурсивно находим его стоимость. Если такую крышку можно где-то купить отдельно, то price[mask & ~other_mask] != inf и тогда можно прибавить к нему стоимость этого набора и сравнить с исходным значением price[mask]. Берем наименьший.

в элемент price[mask] будет содержать минимальную стоимость покупки такого набора, или inf, если нельзя его собрать.