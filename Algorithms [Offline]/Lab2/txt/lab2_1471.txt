Фактическая цель задачи: найти наименьшего общего предка двух вершин (lca) и найти вес такого пути между вершинами, проходящего через lca.

Входные данные представим в виде матрицы смежности вершин с поддержкой весов ребер.

Функция depth_search_construct(int vert) от вершины заполняет структуры данных, используя поиск в глубину от выбранной вершины.
Массив weight[] хранит вес пути из корня к текущей вершине.
Массив depth[] хранит глубину вершины относительно корня.

Используется метод двоичного подъема.
В двумерном массиве parent второе измерение отвечает за уровень предка вершины. Причем это 2^nth родитель,
что позволяет потом находить наименьшего общего предка lca за log(N).
Число вторых измерений должно быть не меньше log(N) + 1.

Ход решения:
Рекурсивно вызываем depth_search_construct(v), чтобы найти первых предков (родителей) всех вершин, вес пути от них до корня и глубину.

Следующим шагом вычисляем предков (родителей родителей) следующих уровней для вершин.
Структуры построены. Отвечаем на запросы.

Для каждой пары вершин находим наименьшего общего предка. Прежде, чем это сделать необходимо поднять вершины на один уровень. Если после этого вершины совпали, то lca найден, иначе ищем предка parent.

Итоговый вес пути вычисляется как сумма весов путей от корня до вершин минус удвоенный вес пути из lca до вершины (он учитывается дважды: в weight[v1] и weight[v2])