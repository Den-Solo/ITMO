Стеки храним в одном длинном массиве (stacks) блоками по несколько элементов (block_size). Стеков всегда ровно 1000 штук. Оставшееся место массива (MAX - 1000 * block_size)  делится на такие же блоки, в которые дописываются значения стеков при переполнении. Каждый блок размера block_size содержит block_size - 1 элементов, потому что на нулевой позиции каждого блока стоит индекс последнего значения  + 1 из предыдущего блока стека, который переполнился (возвратное значение).
Для каждого стека (1 - 1000) хранится индекс текущего свободного элемента в массиве idxs.
Пусть размер блока 16, тогда после записи 15 элементов он попытается найти свободный блок и продолжить записывать туда значения. Причем на нулевое место нового блока будет записан индекс последнего элемента предыдущего + 1.
Если после извлечения блока он опустошается, то чтобы возвратить память, номер этого блока (не индекс начала, всего блоков = размер массива / размер блока) кладется в стек, откуда он может быть извлечен, если какой-то блок снова переполнится.
Вся сложность состояла в выборе подходящего размера блока и способности догадаться использовать сишный ввод/вывод, вместо с++ потоков, которые занимают на 100КБ больше памяти.