Идея в том, что все, чем надо озаботиться - это определить, где войти в последовательность одинаковой влажности: с самого левого цветка или с самого правого для лучшего следующего перехода (иных варинатов нет, так как любые перемещения внутри последовательности минимальны, лишь если двигаться в одном направлении)

Действуем как в задаче про конвейеры из лекции про ДП.
Сразу создаем две переменные - одну для суммы переходов, если выходить слева из последовательности наименее влажных цветов (l_sum), вторую - справа этой последовательности (r_sum). И для каждой новой влажности при продвижении выбираем лучший  путь 7:37 13.05.2020(наименьший).

1) l_sum равен минимальной сумме из (l_sum предыдущего и пути мужду координатой выхода предыдущего для  l_sum (т. е. левая позиция) и правого конца нового интервала) и (r_sum предыдущего и пути мужду координатой выхода предыдущего для r_sum и правого конца нового интервала)
для r_sum аналогично с учетом, что начинается его интервал в левой точке и заканчиватеся в правой


Подробно:
1) Считываем уникальные значения влажностей в массив wetness;
2) Координаты влажностей добавляем в хэш таблицу dists[влажность][индексы]
3) сортируем wetness
4) создаем массив пар lr_pos, где каждой влажности из wetness соответсвует пара начала и конца интервала цветов такой влажности (разумеется, внутри этого интервала могут быть любые другие влажности)
5) используем выше описанную идею, чтобы просчитать кратчайший путь между цветами (оптимизируем вход и выход последовательностей).