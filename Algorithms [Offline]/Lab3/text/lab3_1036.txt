Вся задача состоит в необходимости реализовать длинную арифметику, так как число вариантов может быть большим.

Если без длинной арифметики: 
1) Проходимся по разрядам номера билета.
Руккурентное соотношение.
opt_cnt[len][sum] += opt_cnt[len-1][sum-k] for k = [0..9]
то есть сумма ех вариантов последовательностей длины меньшей на единицу и суммы меньшей на число, равное цифре, участвующй в получении новой суммы

2) так как мы вычисляли результат для половины номера билета, необходимо каждый вариант умножить на количество таких вариантов.
если
 2 2
то

01
10

и для каждого из них подходят оба 0101, 1001, 1001, 1010 

так как в stl нет длинной арифметики, реализуем ее
будем хранить в векторах числа по модулю 10. Реккурентная формула та же, но двумерный массив option_cnt[0..sum][0..N * 2] хранит не кол-во вариантов для суммы и длины последовательности, а массив чисел по модулю 10, которые представляют собой длинной число.